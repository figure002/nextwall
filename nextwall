#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# nextwall - a script to change to a random background image
#
#  Copyright 2004, Davyd Madeley <davyd@madeley.id.au>
#  Copyright 2010, Serrano Pereira <figure002@gmail.com>
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import os
import random
import logging
import mimetypes
import getopt
import commands
import threading
from time import localtime, strftime, sleep

import xdg.BaseDirectory as basedir
from pysqlite2 import dbapi2 as sqlite
import gconf
import gobject

import pygtk
pygtk.require('2.0')
import gtk
try:
    import appindicator
except ImportError as ie:
    sys.exit(str(ie))

gobject.threads_init()

__version__ = "1.0"

class NextWall(threading.Thread):
    """The main class."""

    def __init__(self):
        super(NextWall, self).__init__()

        self.argv = sys.argv[1:] # User arguments
        self.recursive = False # Enable recursion
        self.applet = False # Display Application Indicator
        self.fit_time = False # Fit time of day
        self.populate_db = False # Analyze all image files
        self.path = "/usr/share/backgrounds/" # Backgrounds folder
        self.client = gconf.client_get_default() # GConf client
        self.kurtosis_threshold = (0.0, 2.0) # <=first item = Night; >=second item = Day; In between = Dusk/Dawn
        self.dawn_start = 9 # Hour at which dawn starts
        self.day_start = 12 # Hour at which day starts
        self.dusk_start = 18 # Hour at which dusk starts
        self.night_start = 21 # Hour at which night starts
        self.data_home = os.path.join(basedir.xdg_data_home, 'nextwall') # User's data folder
        self.dbfile = "%s/nextwall.db" % (self.data_home) # Path to database file

        # Check for user defined options.
        try:
            opts, args = getopt.getopt(self.argv, "hratv",
                ["help","recursive","applet","fit-time","verbose",
                    "populate-db"])
        except getopt.GetoptError:
            self.usage()

        for opt, arg in opts:
            if opt in ("-h", "--help"):
                self.usage()
            if opt in ("-r", "--recursive"):
                self.recursive = True
            if opt in ("-a", "--applet"):
                self.applet = True
            if opt in ("-t", "--fit-time"):
                self.set_fit_time(True)
            if opt in ("-v", "--verbose"):
                logging.basicConfig(level=logging.INFO,
                    format='%(levelname)s %(message)s')
            if opt in ("--populate-db"):
                self.populate_db = True

                # Turn on verbose mode, so the user knows what's happening.
                logging.basicConfig(level=logging.INFO,
                    format='%(levelname)s %(message)s')

        # Check if the data folder exists. If not, create it.
        if not os.path.exists(self.data_home):
            logging.info("Creating data folder %s" % (self.data_home))
            os.mkdir(self.data_home)

        # Check if the database file exists. If not, create it.
        if not os.path.isfile(self.dbfile):
            logging.info("Creating database file %s" % (self.dbfile))
            self.make_db()

        # Set the backgrounds folder.
        self.set_backgrounds_folder(args)

        # Check if we need to populate the database.
        if self.populate_db:
            logging.info("This could take a while, depending on the number of images in the\n"
                "\tspecified folder. Starting in 10 seconds...")
            sleep(10)
            self._populate_db()
            sys.exit()

        # Decide what to do next.
        if self.applet:
            # Show the applet.
            Indicator(self)
        else:
            # Change the background.
            self.change_background()

    def usage(self):
        """Print usage information."""
        print "nextwall %s" % (__version__)
        print "\nUsage: %s [options] [path]" % ( os.path.split(sys.argv[0])[1] )
        print "  [path]\tPath to folder containing background images."
        print "\t\tIf no path is specified, the default path"
        print "\t\t/usr/share/backgrounds/ will be used."
        print "\nOptions:"
        print "  -h, --help\t\tShow usage information."
        print "  -r, --recursive\tLook in subfolders."
        print "  -a, --applet\t\tRun as applet in the GNOME panel."
        print ("  -t, --fit-time\tSelect backgrounds that fit the time of day. It is\n"
                "\t\t\trecommended to use --populate-db first.")
        print ("      --populate-db\tAnalyze all images in [path] and save the information\n"
                "\t\t\tto a database file. This drastically speeds up the\n"
                "\t\t\tprogram if the fit-time option is enabled.")
        print "  -v, --verbose\t\tTurn on verbose output."
        sys.exit()

    def set_backgrounds_folder(self, path):
        """Set the backgrounds folder."""
        if type(path) == type([]):
            # Get the path from the given argument.
            if len(path) == 0:
                # If no argument was set, use the default path.
                return
            elif len(path) == 1:
                # If argument was given, use this as the path.
                path = os.path.abspath(path[0])
            else:
                self.usage()

        # Check if the backgrounds folder is valid.
        if not os.path.exists(self.path):
            print ("The folder %s doesn't seem to exist.\n"
                "Run '%s --help' for usage information." %
                (self.path, os.path.split(sys.argv[0])[1]))
            sys.exit(1)

        # Set the new folder.
        logging.info("Setting backgrounds folder to %s" % (path))
        self.path = path

    def set_fit_time(self, boolean):
        """Setter for fit_time."""
        if not boolean:
            self.fit_time = False
            return

        # Make sure the identify command is available.
        if not self._check_command('identify'):
            message = ("Unmet dependency: identify (ImageMagick) - "
                "The 'fit-time' feature requires the 'identify' "
                "tool (member of ImageMagick). The 'fit-time' feature has been disabled.")

            if self.applet:
                dialog = gtk.MessageDialog(parent=None, flags=0,
                    type=gtk.MESSAGE_INFO, buttons=gtk.BUTTONS_OK,
                    message_format=message)
                response = dialog.run()

                if response == gtk.RESPONSE_OK:
                    dialog.destroy()
                    return
            else:
                print message
                return

        self.fit_time = True

    def _check_command(self, command):
        """Check if a specific command is available."""
        cmd = 'which %s' % (command)
        output = commands.getoutput(cmd)
        if len(output.splitlines()) == 0:
            return False
        else:
            return True

    def get_files_recursively(self, rootdir):
        """Recursively get a list of files from a folder."""
        file_list = []

        for root, sub_folders, files in os.walk(rootdir):
            for file in files:
                file_list.append(os.path.join(root,file))

            # Don't visit thumbnail directories.
            if '.thumbs' in sub_folders:
                sub_folders.remove('.thumbs')

        return file_list

    def get_files(self, rootdir):
        """Non-recursively get a list of files from a folder."""
        file_list = []

        files = os.listdir(rootdir)
        for file in files:
            file_list.append(os.path.join(rootdir,file))

        return file_list

    def get_image_kurtosis(self, file):
        """Return kurtosis, a measure of the peakedness of the
        probability distribution of a real-valued random variable.

        First check if the imaga kurtosis can be found in the database.
        If it's not in the database, calculate it using ImageMagick's
        'identify' and save the value to the database.
        """
        # Try to get the image kurtosis from the database.
        logging.info("Getting image information from the database...")
        connection = sqlite.connect(self.dbfile)
        cursor = connection.cursor()
        cursor.execute("SELECT kurtosis FROM wallpapers WHERE path=?", [file])
        kurtosis = cursor.fetchone()
        cursor.close()
        connection.close()

        if not kurtosis:
            # If kurtosis not found in the database, calculate it.

            logging.info("..not found in database.")

            # Use identify to calculate the image kurtosis.
            logging.info("Calculating image kurtosis...")
            cmd = 'identify -verbose "%s" | grep kurtosis' % (file)
            output = commands.getoutput(cmd)
            output = output.splitlines()
            items = len(output)

            # Handle exceptions.
            if items == 0:
                return 0

            # Get the last kurtosis calculation, which is the overall.
            output = output[items-1].split()

            # The second part is the kurtosis value.
            kurtosis = output[1]

            # Save the calculated kurtosis to the database.
            logging.info("Saving image information to database...")
            self.save_to_db(file, kurtosis)
        else:
            logging.info("..found in database.")
            kurtosis = kurtosis[0]

        logging.info("\tOverall image kurtosis: %s" % (kurtosis))

        return float(kurtosis)

    def save_to_db(self, path, kurtosis):
        connection = sqlite.connect(self.dbfile)
        cursor = connection.cursor()
        cursor.execute("INSERT INTO wallpapers VALUES (null, ?, ?)", [path, kurtosis])
        connection.commit()
        cursor.close()
        connection.close()

    def make_db(self):
        """Create an empty database with the necessary tables."""
        db_version = "0.1"
        connection = sqlite.connect(self.dbfile)
        cursor = connection.cursor()
        cursor.execute("CREATE TABLE wallpapers (id INTEGER PRIMARY KEY, path TEXT, kurtosis FLOAT)")
        cursor.execute("CREATE TABLE info (id INTEGER PRIMARY KEY, name VARCHAR, value VARCHAR)")
        cursor.execute("INSERT INTO info VALUES (null, 'version', ?)", [db_version])
        connection.commit()
        cursor.close()
        connection.close()

    def _populate_db(self):
        """Calculate the image kurtosis for each image in the selected
        folder and save it to the database.
        """
        images = self.get_image_files()
        self.populate_total = len(images)

        # Get the image kurtosis of each file and save it to the
        # database.
        i = 1
        for image in images:
            self.populate_current = i
            logging.info("Found %s" % (image))
            self.get_image_kurtosis(image)
            i += 1

        logging.info("Database successfully populated.")

    def get_image_brightness(self, file, get=False):
        """Decide wether a kurtosis value is considered bright or dark

        Dark: return 0
        Medium: return 1
        Bright: return 2
        """
        kurtosis = self.get_image_kurtosis(file)

        if kurtosis < self.kurtosis_threshold[0]:
            # Bright
            brightness = 2
        elif kurtosis > self.kurtosis_threshold[1]:
            # Dark
            brightness = 0
        else:
            # Medium
            brightness = 1

        logging.info("\tBrightness value: %d" % (brightness))

        if get:
            return (kurtosis, brightness)

        return brightness

    def match_image_time(self, file):
        """Decide whether the image's brightness is suitable for the
        time of day.

        Suitable: return True
        Not Suitable: return False
        """
        brightness = self.get_image_brightness(file)
        hour = int(strftime("%H", localtime()))

        # Decide based on current time which brightness value (0,1,2)
        # is expected.
        if hour >= self.day_start and hour < self.dusk_start:
            # Day
            target = 2
        elif hour >= self.night_start or hour < self.dawn_start:
            # Night
            target = 0
        else:
            # Dawn/Dusk
            target = 1

        logging.info("\tTarget brightness value: %d" % (target))

        # Compare image value with target value.
        if brightness == target:
            return True
        else:
            return False

    def get_image_files(self):
        """Return a list of image files from the specified folder."""
        if self.recursive:
            # Get the files from the backgrounds folder recursively.
            dir_items = self.get_files_recursively(self.path)
        else:
            # Get the files from the backgrounds folder non-recursively.
            dir_items = self.get_files(self.path)

        # Check if the background items are actually images. Approved
        # files are put in 'images'.
        images = []
        for item in dir_items:
            mimetype = mimetypes.guess_type(item)[0]
            if mimetype and mimetype.split('/')[0] == "image":
                images.append(item)

        return images

    def change_background(self, widget=None, data=None):
        """Change background according to given arguments."""
        # Get a list of the image files.
        images = self.get_image_files()

        # Check if any image files were found.
        if len(images) < 2:
            message = ("No image files (or just one) were found in '%s'\n"
                "Set a different backgrounds folder or enable recursion to "
                "look in subfolders.") % (self.path)
            if self.applet:
                dialog = gtk.MessageDialog(parent=None, flags=0,
                    type=gtk.MESSAGE_INFO, buttons=gtk.BUTTONS_OK,
                    message_format=message)
                response = dialog.run()

                if response == gtk.RESPONSE_OK:
                    dialog.destroy()
                    return
            else:
                print message
                sys.exit(1)

        # Get a random background item from the file list.
        item = random.randint(0, len(images) - 1)

        # Get the current background used by GNOME.
        current_bg = self.client.get_string("/desktop/gnome/background/picture_filename")

        sames = 0
        for i in range(20): # Give up after 20 tries.
            # Stop the loop if we find the same image 3 times.
            if sames == 3:
                break

            logging.info("[%d] Found %s" % (i+1, images[item]))

            # Make sure the random background item isn't the same as the
            # background currently being used.
            while(images[item] == current_bg):
                sames += 1
                item = random.randint(0, len(images) - 1)

                logging.info("..same as current, found %s" % (images[item]))

            # Check if the image brightness matches the current time.
            if self.fit_time:
                if self.match_image_time(images[item]):
                    # Match; set this background.
                    break
                else:
                    # No match; select random background and do the loop
                    # again (if maximum tries not exeeded).
                    item = random.randint(0, len(images) - 1)

                    logging.info("..does not match time of day.")
            else:
                break

        # Finally, set the new background.
        logging.info("Setting background %s" % (images[item]))
        self.client.set_string("/desktop/gnome/background/picture_filename",
            images[item])

class Indicator(object):
    """Display an Application Indicator in the GNOME panel."""

    def __init__(self, main):
        self.main = main

        # Create an Application Indicator icon
        ind = appindicator.Indicator("nextwall",
            "gsd-xrandr",
            appindicator.CATEGORY_OTHER)
        ind.set_status(appindicator.STATUS_ACTIVE)

        # Create GTK menu
        menu = gtk.Menu()

        # Create the menu items
        change_item = gtk.MenuItem("Next Wallpaper")
        info_item = gtk.MenuItem("Image Information")
        open_item = gtk.MenuItem("Open Current")
        delete_item = gtk.MenuItem("Delete Current")
        populate_item = gtk.MenuItem("Analyze All Images")
        pref_item = gtk.MenuItem("Preferences")
        quit_item = gtk.MenuItem("Quit")
        separator = gtk.SeparatorMenuItem()

        # Add them to the menu
        menu.append(change_item)
        menu.append(info_item)
        menu.append(open_item)
        menu.append(delete_item)
        menu.append(populate_item)
        menu.append(separator)
        menu.append(pref_item)
        menu.append(quit_item)

        # Attach the callback functions to the activate signal
        change_item.connect("activate", self.main.change_background)
        info_item.connect("activate", self.on_image_info)
        open_item.connect("activate", self.on_open_current)
        delete_item.connect("activate", self.on_delete_current)
        populate_item.connect("activate", self.on_populate_db)
        pref_item.connect("activate", self.on_preferences)
        quit_item.connect("activate", self.on_quit)

        # Show menu items
        menu.show_all()

        # Add the menu to the Application Indicator
        ind.set_menu(menu)

        # Run the main loop
        gtk.main()

    def on_image_info(self, widget, data=None):
        """Display image information."""
        ImageInformation(self.main)

    def on_quit(self, widget, data=None):
        """Exit the application."""
        gtk.main_quit()

    def on_preferences(self, widget, data=None):
        """Display preferences window."""
        Preferences(self.main)

    def on_delete_current(self, widget, data=None):
        """Delete the current background image from the harddisk."""
        current_bg = self.main.client.get_string("/desktop/gnome/background/picture_filename")
        message = ("This will <b>permanently</b> remove the current background "
            "image (%s) from your harddisk.") % (current_bg)

        dialog = gtk.MessageDialog(parent=None, flags=0,
            type=gtk.MESSAGE_WARNING, buttons=gtk.BUTTONS_YES_NO,
            message_format=None)
        dialog.set_markup(message)
        dialog.format_secondary_text("Continue?")
        response = dialog.run()

        if response == gtk.RESPONSE_YES:
            logging.info("Removing %s" % (current_bg))
            os.remove(current_bg)
            dialog.destroy()
        else:
            dialog.destroy()
            return

        self.main.change_background()

    def on_open_current(self, widget, data=None):
        """Open the current background with the system's default image
        viewer.
        """
        current_bg = self.main.client.get_string("/desktop/gnome/background/picture_filename")
        os.system('xdg-open "%s"' % (current_bg))

    def on_populate_db(self, widget, data=None):
        """Run the main._populate_db function in a separate thread, and
        show a nice progress dialog.
        """
        # Display a Progress Dialog.
        label = ("NextWall is now calculating the brightness value for each image file in the specified folder. "
            "This brightness value is required for the \"fit time of day\" feature. "
            "Depending on the number of images files, this may take a while. "
            "Completing this analysis is recommended, as this will speed up the application drastically.")
        pgd = ProgressDialog(self.main, "Analyzing Images", label)

        # Start the PopulateDB class in a new thread.
        pdb = PopulateDB(pgd)
        pdb.start()


class ImageInformation(gtk.Window):
    """Display a dialog showing the image information."""

    def __init__(self, main):
        self.main = main
        super(ImageInformation, self).__init__()

        self.set_title("Image Information")
        self.set_size_request(-1, -1)
        self.set_border_width(10)
        self.set_position(gtk.WIN_POS_CENTER)
        self.set_resizable(False)
        self.set_keep_above(True)

        current_bg = self.main.client.get_string("/desktop/gnome/background/picture_filename")
        info = self.main.get_image_brightness(file=current_bg, get=True)
        if info[1] == 0:
            time = "Night"
        elif info[1] == 1:
            time = "Dusk/Dawn"
        elif info[1] == 2:
            time = "Day"

        # Create table container
        table = gtk.Table(rows=4, columns=2, homogeneous=False)
        table.set_col_spacings(10)
        table.set_row_spacings(10)

        # Text label
        label_file = gtk.Label("Image path:")
        label_file.set_alignment(1.0, 0)
        table.attach(child=label_file, left_attach=0, right_attach=1,
            top_attach=0, bottom_attach=1, xoptions=gtk.FILL,
            yoptions=gtk.FILL, xpadding=0, ypadding=0)

        # Value
        text_file = gtk.Label(current_bg)
        text_file.set_alignment(0, 1.0)
        text_file.set_line_wrap(True)
        text_file.set_selectable(True)
        table.attach(child=text_file, left_attach=1, right_attach=2,
            top_attach=0, bottom_attach=1, xoptions=gtk.FILL|gtk.EXPAND,
            yoptions=gtk.FILL, xpadding=0, ypadding=0)

        # Text label
        label_kurtosis = gtk.Label("Kurtosis:")
        label_kurtosis.set_alignment(1.0, 0)
        table.attach(child=label_kurtosis, left_attach=0, right_attach=1,
            top_attach=1, bottom_attach=2, xoptions=gtk.FILL|gtk.EXPAND,
            yoptions=gtk.FILL, xpadding=0, ypadding=0)

        # Value
        text_kurtosis = gtk.Label(info[0])
        text_kurtosis.set_alignment(0, 1.0)
        text_kurtosis.set_selectable(True)
        table.attach(child=text_kurtosis, left_attach=1, right_attach=2,
            top_attach=1, bottom_attach=2, xoptions=gtk.FILL|gtk.EXPAND,
            yoptions=gtk.FILL, xpadding=0, ypadding=0)

        # Text label
        label_brightness = gtk.Label("Brightness value:")
        label_brightness.set_alignment(1.0, 0)
        table.attach(child=label_brightness, left_attach=0, right_attach=1,
            top_attach=2, bottom_attach=3, xoptions=gtk.FILL|gtk.EXPAND,
            yoptions=gtk.FILL, xpadding=0, ypadding=0)

        # Value
        text_brightness = gtk.Label("%d (%s)" % (info[1], time))
        text_brightness.set_alignment(0, 1.0)
        text_brightness.set_selectable(True)
        table.attach(child=text_brightness, left_attach=1, right_attach=2,
            top_attach=2, bottom_attach=3, xoptions=gtk.FILL|gtk.EXPAND,
            yoptions=gtk.FILL, xpadding=0, ypadding=0)

        # OK button
        button_ok = gtk.Button("OK")
        button_ok.set_size_request(70, -1)
        button_ok.connect("clicked", self.on_ok)

        # Put the buttons in a box
        button_box = gtk.HBox(homogeneous=True, spacing=5)
        button_box.add(button_ok)

        # Align the button box
        buttons_align = gtk.Alignment(xalign=0.5, yalign=0, xscale=0, yscale=0)
        buttons_align.add(button_box)

        # Add the aligned box to the table
        table.attach(child=buttons_align, left_attach=0, right_attach=2,
            top_attach=3, bottom_attach=4, xoptions=gtk.FILL,
            yoptions=gtk.SHRINK, xpadding=0, ypadding=0)

        # Add the table to the main window.
        self.add(table)

        # Make it visible.
        self.show_all()

    def on_ok(self, widget, data=None):
        """Close the dialog."""
        self.destroy()


class Preferences(gtk.Window):
    """Display a preferences dialog which allows the user to configure
    the application.
    """

    def __init__(self, main):
        self.main = main
        super(Preferences, self).__init__()

        self.set_title("Preferences")
        self.set_size_request(400, -1)
        self.set_border_width(10)
        self.set_position(gtk.WIN_POS_CENTER)
        self.set_resizable(False)
        self.set_keep_above(True)

        # Create table container
        table = gtk.Table(rows=4, columns=2, homogeneous=False)
        table.set_col_spacings(10)
        table.set_row_spacings(10)

        # Create a label
        title = gtk.Label("Select backgrounds folder:")
        table.attach(child=title, left_attach=0, right_attach=1,
            top_attach=0, bottom_attach=1, xoptions=gtk.FILL,
            yoptions=gtk.SHRINK, xpadding=0, ypadding=0)

        # Create a file chooser button
        self.folderselect = gtk.FileChooserButton('Select a folder')
        self.folderselect.set_action(gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER)
        self.folderselect.set_current_folder(self.main.path)
        table.attach(child=self.folderselect, left_attach=1, right_attach=2,
            top_attach=0, bottom_attach=1, xoptions=gtk.FILL|gtk.EXPAND,
            yoptions=gtk.SHRINK, xpadding=0, ypadding=0)

        # Create a checkbutton for recusrion
        self.check_recursion = gtk.CheckButton("Enable recursion (look in subfolders)")
        if self.main.recursive:
            self.check_recursion.set_active(True)
        #self.check_recursion.unset_flags(gtk.CAN_FOCUS)
        table.attach(child=self.check_recursion, left_attach=0, right_attach=2,
            top_attach=1, bottom_attach=2, xoptions=gtk.FILL|gtk.EXPAND,
            yoptions=gtk.SHRINK, xpadding=0, ypadding=0)

        # Create a checkbutton for match time
        self.check_fit_time = gtk.CheckButton("Select backgrounds that fit the time of day")
        if self.main.fit_time:
            self.check_fit_time.set_active(True)
        #self.check_fit_time.unset_flags(gtk.CAN_FOCUS)
        table.attach(child=self.check_fit_time, left_attach=0, right_attach=2,
            top_attach=2, bottom_attach=3, xoptions=gtk.FILL|gtk.EXPAND,
            yoptions=gtk.SHRINK, xpadding=0, ypadding=0)

        # About button
        button_about = gtk.Button("About")
        button_about.set_size_request(70, -1)
        button_about.connect("clicked", self.on_about)
        about_align = gtk.Alignment(xalign=0, yalign=0, xscale=0, yscale=0)
        about_align.add(button_about)
        table.attach(child=about_align, left_attach=0, right_attach=1,
            top_attach=3, bottom_attach=4, xoptions=gtk.FILL,
            yoptions=gtk.SHRINK, xpadding=0, ypadding=0)

        # OK button
        button_ok = gtk.Button("OK")
        button_ok.set_size_request(70, -1)
        button_ok.connect("clicked", self.on_ok)

        # Cancel button
        button_cancel = gtk.Button("Cancel")
        button_cancel.set_size_request(70, -1)
        button_cancel.connect("clicked", self.on_cancel)

        # Put the buttons in a box
        button_box = gtk.HBox(homogeneous=True, spacing=5)
        button_box.add(button_cancel)
        button_box.add(button_ok)

        # Align the button box
        buttons_align = gtk.Alignment(xalign=1.0, yalign=0, xscale=0, yscale=0)
        buttons_align.add(button_box)

        # Add the aligned box to the table
        table.attach(child=buttons_align, left_attach=1, right_attach=2,
            top_attach=3, bottom_attach=4, xoptions=gtk.FILL,
            yoptions=gtk.SHRINK, xpadding=0, ypadding=0)

        # Add the table to the main window.
        self.add(table)

        # Make it visible.
        self.show_all()

    def on_ok(self, widget, data=None):
        """Save new settings and close the preferences dialog."""
        # Set the new backgrounds folder.
        self.main.set_backgrounds_folder( self.folderselect.get_filename() )

        # Set recursion.
        if self.check_recursion.get_active():
            self.main.recursive = True
        else:
            self.main.recursive = False

        # Set match time.
        if self.check_fit_time.get_active():
            self.main.set_fit_time(True)
        else:
            self.main.set_fit_time(False)

        # Destroy the dialog.
        self.destroy()

    def on_cancel(self, widget, data=None):
        """Close the preferences dialog."""
        self.destroy()

    def on_about(self, widget, data=None):
        license = ("This program is free software: you can redistribute it and/or modify\n"
            "it under the terms of the GNU General Public License as published by\n"
            "the Free Software Foundation, either version 3 of the License, or\n"
            "(at your option) any later version.\n\n"

            "This program is distributed in the hope that it will be useful,\n"
            "but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
            "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
            "GNU General Public License for more details.\n\n"

            "You should have received a copy of the GNU General Public License\n"
            "along with this program.  If not, see http://www.gnu.org/licenses/")

        about = gtk.AboutDialog()
        about.set_program_name("NextWall")
        about.set_version(__version__)
        about.set_copyright("Copyright Â© Davyd Madeley, Serrano Pereira")
        about.set_authors(["Davyd Madeley <davyd@madeley.id.au>", "Serrano Pereira <figure002@gmail.com>"])
        about.set_comments("A script to change to a random background image.")
        about.set_license(license)
        about.run()
        about.destroy()



class ProgressDialog(gtk.Window):
    """Show a progress dialog."""

    def __init__(self, main, title, label):
        super(ProgressDialog, self).__init__()
        self.main = main
        self.main.populate_db = True

        self.connect("destroy", self.on_close)
        self.set_size_request(350, -1)
        self.set_title(title)
        self.set_border_width(0)
        self.set_resizable(False)
        self.set_position(gtk.WIN_POS_CENTER)

        # Create a vertical box container.
        vbox = gtk.VBox(homogeneous=False, spacing=5)
        vbox.set_border_width(10)

        # Create a label.
        self.label = gtk.Label()
        self.label.set_line_wrap(True)
        self.label.set_justify(gtk.JUSTIFY_FILL)
        self.label.set_text(label)

        # Create the progress bar.
        self.pbar = gtk.ProgressBar()
        self.pbar.set_fraction(0.0)
        self.pbar.set_orientation(gtk.PROGRESS_LEFT_TO_RIGHT)

        pbar_align = gtk.Alignment(xalign=0.0, yalign=0.0, xscale=1.0, yscale=0.0)
        pbar_align.add(self.pbar)

        # Close button
        button_close = gtk.Button("Close")
        button_close.set_size_request(70, -1)
        button_close.connect("clicked", self.on_close)

        # Put the buttons in a box.
        button_box = gtk.HBox(homogeneous=True, spacing=5)
        button_box.add(button_close)

        buttons_align = gtk.Alignment(xalign=1.0, yalign=0, xscale=0, yscale=0)
        buttons_align.add(button_box)

        # Add the alignment objects to the vertical container.
        vbox.pack_start(child=self.label, expand=False, fill=False, padding=5)
        vbox.pack_start(child=pbar_align, expand=False, fill=False, padding=5)
        vbox.pack_start(child=buttons_align, expand=False, fill=False, padding=0)

        self.add(vbox)
        self.show_all()
        self.show()

    def on_close(self, widget=None, data=None):
        self.main.populate_db = False
        self.destroy()

class PopulateDB(threading.Thread):
    """Analyze all image files in the specified folder and update the
    progress bar in the progress dialog. The result is that all the
    information will be saved to the database file.
    """

    def __init__(self, parent):
        super(PopulateDB, self).__init__()
        self.parent = parent
        self.current = 0
        self.total = 0

    def update_progressbar(self):
        fraction = self.current / float(self.total)
        self.parent.pbar.set_fraction(fraction)
        self.parent.pbar.set_text("%d/%d" % (self.current, self.total))
        if self.current == self.total:
            self.parent.pbar.set_text("Finished!")
        return False

    def run(self):
        """Calculate the image kurtosis for each image in the selected
        folder and save it to the database.
        """
        images = self.parent.main.get_image_files()
        self.total = len(images)

        # Get the image kurtosis of each file and save it to the
        # database.
        i = 1
        for image in images:
            if not self.parent.main.populate_db:
                # Stop the process if 'populate_db' set to False.
                logging.info("Analyze images: stopped by user.")
                return False

            self.current = i
            logging.info("Found %s" % (image))
            gobject.idle_add(self.update_progressbar)
            self.parent.main.get_image_kurtosis(image)
            i += 1

        logging.info("Image files successfully analyzed.")

def adapt_str(string):
    """Convert the custom Python type into one of SQLite's supported
    types.
    """
    return string.decode("utf-8")

if __name__ == "__main__":
    # Registers adapt_str to convert the custom Python type into one of
    # SQLite's supported types. This adds support for Unicode filenames.
    sqlite.register_adapter(str, adapt_str)

    NextWall()
    sys.exit()
